#summary Modifications to Java Topology Suite to allow Spatial Indexes to be persistent in the Google App Engine Datastore

= Introduction =

The GisCloud application is currently storing the polygon for Salt Lake County as Well-Known Text (WKT). For the existing application where we are simply testing a single point-in-polygon and polygon-in-polygon, this is acceptable. However, if we need to do this for many geometries (e.g. if we were testing a point in tracts instead of a point in a county) then fetching each WKT, converting to geometry, and either looping through each to test for inclusion or building a spatial index, just takes too long -- especially if the user is clicking to generate the activity.

However, since we don't have access to a file system on App Engine we must store spatial indexes as binary objects (blobs) in the datastore. And all objects must be serializable to be persisted. Thus, the fix we need in JTS is for spatial indexes to be serializable.

= Details =

While it is easy enough to add `implements Serializable` to classes and `extends Serializable` to interfaces in the `com.vividsolutions.jts.index.*` packages, it took a little digging to see that the `STRtree` (the only class we have tested for now) implements a few comparators that need some work:

{{{
    // a comparator for the x coordinate
    private Comparator xComparator =
    new Comparator() {
      public int compare(Object o1, Object o2) {
        return compareDoubles(
            centreX((Envelope)((Boundable)o1).getBounds()),
            centreX((Envelope)((Boundable)o2).getBounds()));
      }
    };

    // a comparator for the y coordinate
    private Comparator yComparator =
    new Comparator() {
      public int compare(Object o1, Object o2) {
        return compareDoubles(
            centreY((Envelope)((Boundable)o1).getBounds()),
            centreY((Envelope)((Boundable)o2).getBounds()));
      }
    };
}}}

These inline comparators are replaced with two new classes:

{{{
    private BoundableXComparator xComparator = new BoundableXComparator();
    private BoundableYComparator yComparator = new BoundableYComparator();
}}}

which look like this:

{{{
package com.vividsolutions.jts.index.strtree;

import com.vividsolutions.jts.geom.Envelope;

public class BoundableXComparator extends BoundableComparator {

	public int compare(Boundable o1, Boundable o2) {
        return compareDoubles(
                centreX((Envelope)((Boundable)o1).getBounds()),
                centreX((Envelope)((Boundable)o2).getBounds()));
	}
	
}
}}}

and

{{{
package com.vividsolutions.jts.index.strtree;

import com.vividsolutions.jts.geom.Envelope;

public class BoundableYComparator extends BoundableComparator {

	public int compare(Boundable o1, Boundable o2) {
        return compareDoubles(
                centreY((Envelope)((Boundable)o1).getBounds()),
                centreY((Envelope)((Boundable)o2).getBounds()));
	}

}
}}}

Both the X and Y comparators inherit from:

{{{
package com.vividsolutions.jts.index.strtree;

import java.io.Serializable;

/**
 * A spatial object in an AbstractSTRtree.
 *
 * @version 1.7
 */
public interface Boundable extends Serializable {
  /**
   * Returns a representation of space that encloses this Boundable, preferably
   * not much bigger than this Boundable's boundary yet fast to test for intersection
   * with the bounds of other Boundables. The class of object returned depends
   * on the subclass of AbstractSTRtree.
   * @return an Envelope (for STRtrees), an Interval (for SIRtrees), or other object
   * (for other subclasses of AbstractSTRtree)
   * @see AbstractSTRtree.IntersectsOp
   */
  Object getBounds();
}
}}}

which existed before in the JTS code base, but which now extends Serializable.